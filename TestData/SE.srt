1
00:00:00,000 --> 00:00:08,520
So, im letzten Kapitel der Vorlesung Software Engineering 1 oder Einführung in der Software

2
00:00:08,520 --> 00:00:18,680
Engineering dreht es sich um das Thema Software Test. Ja, schauen wir uns mal an, welche Probleme

3
00:00:18,680 --> 00:00:25,120
gibt es mit Software Tests. Wir hatten ja schon mal zwei oder eine ganze Reihe von Beispielen am

4
00:00:25,120 --> 00:00:31,120
Anfang der Vorlesung, wo wir darüber gesprochen haben, ja, warum ist es überhaupt sinnvoll,

5
00:00:31,120 --> 00:00:39,080
strukturiert an eine Softwareentwicklung heranzugehen. Da will ich mal zwei Beispiele

6
00:00:39,080 --> 00:00:47,560
herausgreifen. 1979 ist zwar schon ein älteres Beispiel, aber war ziemlich teuer, sage ich mal,

7
00:00:47,560 --> 00:00:52,840
einfach, hat deutliche Konsequenzen gehabt. Das ist ein sehr einprägsames Beispiel.

8
00:00:53,320 --> 00:01:04,960
Der Steuercomputer einer Venus-Runde, der führte folgenden Befehl aus. Du3 i gleich 1.3. Ja,

9
00:01:04,960 --> 00:01:13,720
dass die Du-Schleife ist in Vortran gleich bedeutend, um in einer geringfügig anderen

10
00:01:13,720 --> 00:01:19,720
Syntax wie die Vorschleife in Java oder in anderen Programmiersprachen, also eine einfache

11
00:01:19,840 --> 00:01:28,880
Zellschleife. So, also hier sollte einfach eine Schleife programmiert werden. Ja,

12
00:01:28,880 --> 00:01:45,480
nur hier gab es ein kleines Problem. Die Zuweisung an sich war gültig. Anstelle von diesem Du können

13
00:01:45,480 --> 00:01:54,840
sich so ein Vor vorstellen. Die 3, das kennzeichnet einfach die letzte Zeile des Schleifenkörpers.

14
00:01:54,840 --> 00:02:06,200
Ja, und dann kommt die Schleifenbedingung i gleich 1.3. Das wurde erfolgreich kompiliert. Ja,

15
00:02:06,200 --> 00:02:12,960
und dementsprechend wurde also kein Fehler festgestellt. Das Ganze lief und die Rakete

16
00:02:12,960 --> 00:02:18,160
flog und ja, flog leider an ihrem Ziel vorbei. Sie können sich vorstellen,

17
00:02:18,160 --> 00:02:26,680
paar Millionen Dollar sind da leider in Rauch oder aufgegangen bzw. ins Nirwana gegangen.

18
00:02:26,680 --> 00:02:35,960
Der Punkt ist nämlich hier der, richtig wäre gewesen, hier sollte einfach eine Schleife

19
00:02:35,960 --> 00:02:44,280
dreimal durchgelaufen werden und zwar mit den Werten i gleich 1, i gleich 2, i gleich 3. So,

20
00:02:44,280 --> 00:02:50,360
und diese Schleife, die Schleifenanfang und Schleifenende wie in einer Vorschleife,

21
00:02:50,360 --> 00:03:02,080
das wird hier eben so aufgezählt. Ja, Schleifenanfang und Schleifenende des Schleifenzählers.

22
00:03:02,080 --> 00:03:08,640
Syntaktisch gültig ist das Ganze hier oben in Fortran, aber deswegen, Fortran ist eine

23
00:03:08,640 --> 00:03:15,480
ältere Programmiersprache, wird teilweise noch genutzt. Ja, gültig ist das, weil man in Fortran

24
00:03:15,480 --> 00:03:28,440
auch über Gleitkommawerte iterieren darf. Ja, da dürfte ich also von 1,3 bis 1,7 iterieren und

25
00:03:28,440 --> 00:03:35,000
das hier wäre jetzt also einfach ein Schleifenanfang und als Schleifenanfang ist der

26
00:03:35,000 --> 00:03:43,760
Wert 1,3 angegeben, also syntaktisch richtig. Ja, und wenn man sowas nicht ordentlich testet,

27
00:03:43,760 --> 00:03:56,280
dann passiert halt schon mal größerer Schaden. Ein anderes Beispiel war der 1984 im Computer

28
00:03:56,440 --> 00:04:04,240
meint, eine Überlaufgefahr für einen Staudamm in Frankreich zu erkennen und dementsprechend

29
00:04:04,240 --> 00:04:10,440
öffnete er einfach mal zwei Schleusentore automatisch. Das führte zu einer Überschwemmung

30
00:04:10,440 --> 00:04:16,520
und viele weitere Beispiele haben wir damals besprochen, auch aus der Neuzeit. Sie entsinnen

31
00:04:16,520 --> 00:04:21,880
sich vor ein paar Jahren, da wurde eine Wahlbeteiligung von über 100 Prozent irgendwie

32
00:04:21,880 --> 00:04:28,240
ermittelt, was ja nun auch keinen Sinn macht. Also auch da sind irgendwelche Prüfungen nicht

33
00:04:28,240 --> 00:04:36,840
ordentlich gewesen. Ja, schauen wir uns mal weiter an, womit sollte man sich denn genauer befassen,

34
00:04:36,840 --> 00:04:43,400
wenn es sich ums Testen handelt. Testen ist einfach nur ein kurzer Begriff, da kann man

35
00:04:43,400 --> 00:04:52,360
was ganz eng abgegrenztes mitmeiden, dass man einfach ausprobiert ist, ein Programm laufig

36
00:04:52,360 --> 00:04:58,520
oder aber man kann aber auch übergeordnete Prozesse darunter verstehen. Deswegen gehen

37
00:04:58,520 --> 00:05:04,280
wir hier jetzt mal kurz auf andere Begriffe ein. Und zwar, Test hat ja immer was mit Qualität zu

38
00:05:04,280 --> 00:05:15,440
tun. Und ja, dementsprechend sind in diesem Umfeld das Testen zu Begriffe üblich, die sich

39
00:05:15,440 --> 00:05:20,880
mit Qualität befassen. Und schauen wir zuerst mal auf den Beruf des Qualitätsmanagements.

40
00:05:20,880 --> 00:05:29,560
Darunter versteht man alle organisatorischen Maßnahmen oder Tätigkeiten und Maßnahmen zum

41
00:05:29,560 --> 00:05:36,520
Leiten und Lenken einer Organisation bezüglich Qualität, sind also Tätigkeiten und Maßnahmen,

42
00:05:36,520 --> 00:05:43,520
die da eine Rolle spielen. Dazu gehörten zum Beispiel die Festlegung von Qualitätszielen,

43
00:05:43,520 --> 00:05:50,560
die Qualitätsplanung, die Qualitätssicherung oder auch die Qualitätsverbesserung. Das ist ein

44
00:05:50,560 --> 00:05:56,160
zentraler Bestandteil von Arbeitsprozessen in ganz vielen Branchen. Qualitätsmanagement,

45
00:05:56,160 --> 00:06:03,400
also in der Automobilindustrie ist das das A und O. Sie wissen, dass wir heutzutage sehr

46
00:06:03,400 --> 00:06:08,480
hochwertige Automobile haben, aber diese Hochwertigkeit oder diese Wertigkeit bekommt

47
00:06:08,480 --> 00:06:15,480
man nur durch ein angemessenes Qualitätsmanagement in den Kopf. In der Luftfahrtindustrie ebenso,

48
00:06:15,480 --> 00:06:23,160
da spielt das Qualitätsmanagement nicht nur in den Komfortbereich hinein, sondern schlichtweg

49
00:06:23,960 --> 00:06:29,400
in die Sicherheit. Das sind nur zwei Beispiele von Branchen. Es gibt, eigentlich soll ich da

50
00:06:29,400 --> 00:06:35,600
drei Prümpchen hinter machen, noch ganz viele weitere Beispiele. Ab zur Ganzen vom Qualitätsmanagement

51
00:06:35,600 --> 00:06:42,440
ist die Qualitätssicherung, das ist nämlich eigentlich nur ein Teil des Qualitätsmanagements,

52
00:06:42,440 --> 00:06:51,200
wie sich hier oben auch ausdrückt. Hier oben habe ich die Qualitätssicherung als Teil des

53
00:06:51,200 --> 00:06:57,480
Qualitätsmanagements schon aufgeführt. Hierbei geht es einfach um die Einhaltung der vereinbarten

54
00:06:57,480 --> 00:07:04,160
Arbeitsprozesse zur Vermeidung von Fehlerzuständen, also um die Analyse der Ursachen für Fehler.

55
00:07:04,160 --> 00:07:12,360
Das Qualitätsmanagement dient der Erkennung, also dem Testen, unter Beseitigung von Fehlerzuständen.

56
00:07:12,360 --> 00:07:20,360
Testen ist also eigentlich in diesem Sinne hier nur die Erkennung von Fehlerzuständen.

57
00:07:20,360 --> 00:07:27,040
Ja, und ein Test ist also auch ein Mittel zur Erreichung eines angemessenen Qualitätsniveaus.

58
00:07:27,040 --> 00:07:37,160
Ja, was wir also festhalten können ist, Test ist ungleich von Qualitätssicherung und eigentlich hätte

59
00:07:37,160 --> 00:07:42,600
ich das hier auch noch erweitern können. Qualitätssicherung ist ungleich mit Qualitätsmanagement,

60
00:07:42,600 --> 00:07:48,080
aber ich denke, dass es hier jetzt durch die Folie auch zum Ausdruck kommt. Welche Probleme

61
00:07:48,080 --> 00:07:55,200
gibt es denn bei der Durchführung von Softwaretests? Wir befassen uns hier jetzt in dieser Stunde

62
00:07:55,200 --> 00:08:03,040
natürlich nur mit dem enger eingegrenzten Begriff der Softwaretests. Und zum einen haben wir den

63
00:08:03,040 --> 00:08:11,840
Aufwand. Bei komplexen Produkten gibt es da einen erhöhten Zeit- und Personalaufwand. Aber man sollte

64
00:08:11,840 --> 00:08:24,240
gleich sich bewusst machen, wenn man hochwertige Produkte seriös entwickeln möchte, egal ob das

65
00:08:24,240 --> 00:08:29,680
in der Automobilindustrie ist, Luftfahrt, die haben wir genannt, oder auch so Unternehmen wie Siemens,

66
00:08:29,680 --> 00:08:38,880
also große Unternehmen oder auch Unternehmen wie SAP, die größere Softwareprodukte erstellen,

67
00:08:39,000 --> 00:08:47,160
die leisten sich auch eigene Testabteilungen. Ich kenne das aus meinem eigenen Umfeld heraus auch.

68
00:08:47,160 --> 00:08:54,960
Da bin ich Softwareentwicklungsabteilungen begegnet, die gar nicht so groß waren wie

69
00:08:54,960 --> 00:09:02,440
jetzt so eine Siemens oder IBM oder SAP. Nee, das waren 30-40 Leute, aber die hatten eine kleine

70
00:09:02,440 --> 00:09:08,400
Testabteilung für ihre Produkte schon installiert. Die bestand dann eben nur aus zwei Mitarbeitern.

71
00:09:08,400 --> 00:09:17,160
Aber immerhin, der große Vorteil ist, wenn ich da eine eigene Abteilung rausmache, und das ist

72
00:09:17,160 --> 00:09:25,280
vielleicht die wichtigste Aussage hierbei, dass Entwicklung und Test von verschiedenen Personen

73
00:09:25,280 --> 00:09:32,800
ausgeführt werden sollten. Denn der Entwickler, das was man selbst entwickelt hat, das kennt man

74
00:09:32,800 --> 00:09:40,400
einfach zu gut. Man hat einen gewissen Blickwinkel da drauf und denkt an verschiedene Konstellationen,

75
00:09:40,400 --> 00:09:45,960
wie man das Produkt auch verwenden könnte, gar nicht. Und da ist es dann sehr praktisch,

76
00:09:45,960 --> 00:09:51,720
wenn da jemand aus einem anderen Blickwinkel heraus rangeht und das dann eben nur testet. Der

77
00:09:51,720 --> 00:09:57,200
hatte mit der Entwicklung gar nichts zu tun. Wie das mit welchen tollen Algorithmen gebaut worden

78
00:09:57,200 --> 00:10:02,840
ist, ist untergeordnet. Der schaut nur danach, was ist das Ergebnis, was klappt vielleicht nicht.

79
00:10:02,840 --> 00:10:10,640
Deswegen ist diese Trennung auf personaler Ebene da außerordentlich hilfreich und macht eben auch

80
00:10:10,640 --> 00:10:17,560
schon bei kleinen Organisationseinheiten Sinn. Ja, weiteres Problem ist die destruktive Grundaufgabe

81
00:10:17,560 --> 00:10:26,240
beim Testen. Ein Test dokumentiert bereits gemachte Fehler. Ja, in der eigenen oder eigene Fehler oder

82
00:10:26,240 --> 00:10:31,320
in der eigenen Abteilung. Da kommt es eben auch nochmal drauf an, wenn das der Entwickler ist,

83
00:10:31,320 --> 00:10:36,280
der selbst testet. Natürlich testet er immer seine einzelnen Methoden, seine einzelnen Unterprogramme,

84
00:10:36,280 --> 00:10:44,960
aber so größere Tests, na ja, wer stellt schon gerne fest, was habe ich jetzt in größerem Stil

85
00:10:44,960 --> 00:10:51,600
verkehrt gemacht. Das ist natürlich auch nicht so eine tolle Aufgabe, auch wenn das Umfeld

86
00:10:51,600 --> 00:11:02,160
entsprechend geartet ist. So, das sind so zwei Problembereiche, wo man mal schnell dran denken

87
00:11:02,160 --> 00:11:07,040
könnte, ach, hier kann man auch ein bisschen dran sparen. Na, war das einerseits zeitaufwendig und

88
00:11:07,040 --> 00:11:11,560
damit personalaufwendig und na ja, eine schöne Aufgabe ist das auch nicht. Zumindest, wenn man

89
00:11:11,560 --> 00:11:20,400
die eigenen Dinge testen soll. Aber daran zu sparen, da kann man nur vorwarnen, denn jedes

90
00:11:20,400 --> 00:11:27,520
Produkt wird getestet. Immer. Nämlich spätestens vom Endbenutzer. Ja, und wenn der Endbenutzer das

91
00:11:27,520 --> 00:11:33,360
testet und vorher zu wenig getestet worden ist, findet er vielleicht auch noch eine ganze Reihe

92
00:11:33,360 --> 00:11:39,120
von Fehlern. Und dann ist mal die Frage zu stellen, wie sieht es denn dann mit dem Kundenvertrauen aus?

93
00:11:39,120 --> 00:11:48,040
Also, da zu groß einzusparen, das sollte man sich sehr, sehr gut überlegen. Das macht ganz einfach

94
00:11:48,040 --> 00:11:55,760
gesagt, vielleicht nur einen schlechten einen. Ja, und dann kommt noch eines hinzu, der Korrekturaufwand.

95
00:11:55,760 --> 00:12:03,520
Je später hier etwas entdeckt wird, je größer ist der Korrekturaufwand. Ja, da die Entwicklung

96
00:12:03,520 --> 00:12:08,000
oftmals schon abgeschlossen ist. Ja, stellen Sie sich vor, der Endbenutzer testet was oder man

97
00:12:08,000 --> 00:12:14,800
testet etwas auch in der Testabteilung. Aber wenn die erst sehr spät ins Boot kommt, also ans Test

98
00:12:14,800 --> 00:12:19,320
kommt, dann ist die Entwicklung oftmals schon abgeschlossen. Konzeptionelle Änderungen,

99
00:12:19,320 --> 00:12:24,640
wo also im Ansatz irgendwie etwas schlecht überlegt worden ist oder einfach nicht bedacht

100
00:12:24,640 --> 00:12:30,960
worden ist, konzeptionelle Änderungen sind dann natürlich nur noch sehr schwer durchzuführen. Und

101
00:12:30,960 --> 00:12:36,760
ist das Produkt erst mal im Einsatz, na ja, dann bewirken kleine Änderungen großen Aufwand. Wenn

102
00:12:36,760 --> 00:12:42,520
das Produkt im Einsatz ist, stellen Sie es mal vor, das ist jetzt mal eine Bank oder Versicherung im

103
00:12:42,520 --> 00:12:47,920
Einsatz und da arbeiten mal so 3000 Leute mit einem Produkt. Wenn Sie da Änderungen durchführen

104
00:12:47,920 --> 00:12:55,520
wollen, dann müssen Sie die allein mal distribuieren. Ja, an die entsprechenden Enduser bringen,

105
00:12:55,520 --> 00:13:02,160
die vielleicht sogar schulen auf ein anderes Verhalten des Produkts. Das heißt also Änderungen im

106
00:13:02,160 --> 00:13:10,600
Produkteinsatz. Da sollte man alles für tun, die zu vermeiden, obwohl letztendlich immer vermeiden

107
00:13:10,760 --> 00:13:18,520
wird es nicht möglich sein. Ja, was sind so mögliche Fehlerquellen? Wir wissen ja alle

108
00:13:18,520 --> 00:13:25,800
als Informatiker, keine Software ist fehlerfrei. Welche Fehlerquellen haben wir? Ja, eine fehlende

109
00:13:25,800 --> 00:13:32,520
Kommunikation, das passiert zum Beispiel in der Teamkoordination, kann laufend passieren.

110
00:13:32,520 --> 00:13:42,040
Sich ändern Anforderungen. Manchmal haben die Kunden die Auftraggeber halt, ja, noch zusätzliche

111
00:13:42,040 --> 00:13:48,120
Ideen. Da ist in der Anforderungsermittlung in der Phase vielleicht irgendwas nicht ganz ideal

112
00:13:48,120 --> 00:13:55,080
gelaufen. Zeitdruck kann so eine Fehlerquelle sein. Teammitglieder, weil die sich einfach, ja,

113
00:13:55,080 --> 00:14:02,640
in den eingesetzten Technologien noch nicht sehr auskennen. Da ist ein Berufsanfänger drin,

114
00:14:02,640 --> 00:14:08,480
der vielleicht in seiner Ausbildung Java gemacht hat und soll jetzt ein C++ Programm schreiben oder

115
00:14:08,480 --> 00:14:15,120
sowas, was er nicht so gerne gelernt hat oder nicht gerne gemacht hat. Vielleicht ist der Code

116
00:14:15,120 --> 00:14:24,200
einfach nur schlecht dokumentiert. Ja, oder bei den Entwicklungswerkzeugen der Arbeit ist etwas. Ja,

117
00:14:24,320 --> 00:14:32,040
dann kommen ganz zuletzt die Programmierfehler, an die man schnell zuerst denkt, aber ich denke,

118
00:14:32,040 --> 00:14:41,960
diese Liste hier zeigt, die Fehlerquellen sind viel, viel, ja, vielseitiger als jetzt nur irgendein

119
00:14:41,960 --> 00:14:50,880
Programmierfehler wie bei dieser Buchleife. Ja, dementsprechend gibt es verschiedene Ebenen

120
00:14:50,960 --> 00:14:55,560
der Durchführung der Qualitätssicherung. Wir haben auf der einen Seite die software spezifische Ebene.

121
00:14:55,560 --> 00:15:02,360
Hier werden praktische Anwendungssituationen gegenübergestellt mit schriftlichen

122
00:15:02,360 --> 00:15:14,360
Spezifikationen. Ja, und software spezifisch natürlich auch ist der Source Code. So, und das

123
00:15:14,360 --> 00:15:19,480
sind Dinge, damit befasst man sich dann im Themenumfeld des Software-Engineering.

124
00:15:19,480 --> 00:15:25,960
Organisationsspezifisch kann man natürlich auch Qualität sicherstellen. Da geht es dann aber mehr

125
00:15:25,960 --> 00:15:31,000
um die Fragen der Projektorganisation und vielleicht der Schulung der Mitarbeiter.

126
00:15:31,000 --> 00:15:39,200
Es gibt, wenn man sich so mit Qualitätssicherung im Software-Umfeld befasst, so sieben Grundsätze

127
00:15:39,200 --> 00:15:45,320
des Testens. Die möchte ich Ihnen jetzt auf den nächsten beiden Folien einmal kurz vorstellen.

128
00:15:45,320 --> 00:15:53,240
Ja, fangen wir mit dem ersten an. Testen zeigt die Anwesenheit von Fehlerzuständen.

129
00:15:53,240 --> 00:16:02,080
Dass also die Situation nur ein Fehler eingetreten ist und das bewirkt halt einen Test. Und was man

130
00:16:02,080 --> 00:16:08,680
versuchen möchte, ist die Reduktion der Wahrscheinlichkeit des Auftrittens weiterer

131
00:16:08,680 --> 00:16:14,720
Fehler. Wenn man keinen Fehlerzustand gefunden hat, naja, dann heißt das aber nicht, dass die

132
00:16:14,720 --> 00:16:22,040
Software fehlerfrei ist. Das ist unsere übliche Erfahrung von allen, die mal Software entwickelt

133
00:16:22,040 --> 00:16:29,720
haben. Ja, ebenso in eine ähnliche Richtung geht ein vollständiges Testen ist unmöglich. Denken

134
00:16:29,720 --> 00:16:36,080
Sie mal an so ein Produkt, was wir alle kennen, Sunworld oder vergleichbar von Konkurrenzprodukten.

135
00:16:36,080 --> 00:16:47,000
Wie viele hunderte von Funktionen gibt es darin? Die kann man nicht alle durchtesten. Manche

136
00:16:47,000 --> 00:16:51,040
Funktionen werden nur sehr selten benutzt. Natürlich wird man sich auf die repräsentativen

137
00:16:51,040 --> 00:16:59,320
Anwendungsfälle stürzen beim Test und sehr viel versuchen auszuprobieren, klappt das alles. Aber

138
00:16:59,320 --> 00:17:07,540
vollständig heißt, jede einzelne Situation der Anwendung auszuprobieren, ist eigentlich nicht

139
00:17:07,540 --> 00:17:15,840
möglich. Ja, dritter Grundsatz greift das auf, was ich gerade eben schon angesprochen habe,

140
00:17:15,840 --> 00:17:23,080
frühes Testen, Sparzeit und Geld. Also nicht erst, wenn das Produkt fertig ist, sondern unter

141
00:17:23,080 --> 00:17:32,040
Umständen zu sehr wohl überlegten Zeitpunkten innerhalb der Entwicklung bereits Tests einplanen.

142
00:17:32,040 --> 00:17:40,000
Denken Sie an gerade so konzeptionelle Fehler, damit man die auch noch beheben kann. Häufung

143
00:17:40,000 --> 00:17:46,640
von Fehlerzuständen. Fehlerzustände sind ungleichmäßig verteilt. Das heißt,

144
00:17:46,640 --> 00:17:52,960
man hat unter Umständen Module, die sehr fehlerzustandsreich sind und die muss man

145
00:17:52,960 --> 00:18:04,000
identifizieren und dort Tests intensivieren. Vorsicht vor dem Pestizidparadoxon. Alte Tests

146
00:18:04,000 --> 00:18:13,520
verlieren ihre Wirkung zur Erkennung von Fehlerzuständen. Weiterentwickelte Programmteile

147
00:18:13,720 --> 00:18:21,680
werden nämlich so nicht erfasst. Das heißt, man hat oder das meint, wenn man viele Tests auch

148
00:18:21,680 --> 00:18:25,200
schon durchgeführt hat, man kann Tests ja durchaus automatisiert auch durchführen.

149
00:18:25,200 --> 00:18:32,720
Da gibt es ja mittlerweile auch Tests, wo man sowas machen kann. Ja, wenn ich dann einfach die

150
00:18:32,720 --> 00:18:42,560
bestehenden Tests nochmal automatisiert ablaufen lasse, dann habe ich zwar getestet,

151
00:18:42,560 --> 00:18:48,360
aber ich habe meine Tests nicht auf neu entwickelte Programmteile angepasst. Die

152
00:18:48,360 --> 00:18:55,440
werden also durch alte Tests nicht erfasst. Das heißt also, ich muss auch meine Tests,

153
00:18:55,440 --> 00:19:03,400
die ich durchführe, immer wieder auf das Programm anpassen. Ja, Testen ist kontextabhängig. Wenn ich

154
00:19:03,400 --> 00:19:07,480
nur Hotelbuchungen durchführen möchte. Jetzt bin ich auf einer Dienstreise und es hat sich

155
00:19:07,480 --> 00:19:15,760
festgestellt, ich muss bei dem Kunden noch einen Tag länger bleiben. Ja, da gibt es dann

156
00:19:15,760 --> 00:19:21,400
unterschiedliche Situationen. Entweder sitze ich bei dem Kunden noch im Büro und darf dessen Rechner

157
00:19:21,400 --> 00:19:27,800
benutzen und kann dann am Desktop vielleicht mein Hotelzimmer für die eine Nacht buchen oder aber

158
00:19:27,800 --> 00:19:37,200
ich bin schon unterwegs, sitze an der Bushaltestelle oder auf dem Bahnsteig und muss über

159
00:19:37,200 --> 00:19:49,520
irgendwelche mobilen Devices mein Hotelzimmer reservieren. Ja, also das Prinzip ist der gleiche

160
00:19:49,520 --> 00:19:58,040
Anwendungsfall, aber ich habe einen unterschiedlichen Kontext. Ja, und weiterer Grundsatz des Testens,

161
00:19:58,040 --> 00:20:06,560
der letzte. Das ist ein Trugschluss. Keine Fehler gefunden bedeutet ein brauchbares System. Das ist

162
00:20:06,560 --> 00:20:18,800
überhaupt nicht der Fall. Software-Tests sind immer Stichproben. Ja, und denken Sie auch daran,

163
00:20:18,800 --> 00:20:25,200
Endnutzer, die können Erwartungen und Erfahrungen mit Alt- und Konkurrenzprodukten einbringen und

164
00:20:25,200 --> 00:20:32,840
haben davon eben auch ihre eigene Zugänge oder Zugangsweise zu einem bestehenden Produkt. Jetzt

165
00:20:32,840 --> 00:20:44,800
kann man Fehler kategorisieren. Ja, das möchte ich mal relativ kurz halten. Fehlerwirkung,

166
00:20:44,800 --> 00:20:51,200
Fehlerhandlung, Fehlerzustand. Zustand ist, wenn der Fehler einfach nur vorliegt. Fehlerwirkung ist

167
00:20:51,200 --> 00:20:59,200
das, was daraus wirklich gemacht wird. Schauen wir mal hier auf zwei Dinge, die mir besonders

168
00:20:59,200 --> 00:21:06,160
wichtig sind bei den Testen von Software-Produkten. Da ist nämlich einerseits der Begriff der

169
00:21:06,160 --> 00:21:13,600
Verifikation und andererseits der Validierung. So, und die Verifikation, dabei handelt es sich um

170
00:21:13,600 --> 00:21:22,360
die Sicherstellung, dass alle Teilergebnisse von Projektentwicklungsphasen konsistent sind. Das

171
00:21:22,360 --> 00:21:27,800
heißt, hier gleiche ich mein Softwareprodukt ab mit dem Pflichtenheft. Ich habe also eine Vorgabe

172
00:21:27,800 --> 00:21:35,680
und prüfe, ist das jetzt richtig umgesetzt, was im Pflichtenheft drin steht? Sind die

173
00:21:35,680 --> 00:21:43,800
funktionalen und nicht funktionalen Anforderungen von der Spezifikation richtig umgesetzt? Ja,

174
00:21:43,800 --> 00:21:52,240
wurde also das System technisch richtig entwickelt. Das kann ich sogar machen, ohne dass ich anwende

175
00:21:52,240 --> 00:21:59,480
einbeziehe. So, und denken wir mal an unsere Praktikumsaufgaben. Da haben wir ja diese

176
00:21:59,480 --> 00:22:08,240
Vermögensverwaltung oder auch die Projektbeantragungssoftware und die Frage, die man hier stellen kann ist eben,

177
00:22:08,240 --> 00:22:17,200
funktioniert die Vermögensverwaltung? Kann ich ein Projekt hier beantragen? Funktioniert das? Und das heißt,

178
00:22:17,200 --> 00:22:22,440
das ist also die Frage hier zu stellen, wurde das System richtig entwickelt? Das ist die

179
00:22:22,440 --> 00:22:32,360
Verifikation. Aber ganz wichtig ist aber auch, und zwar aus Nutzer, aus Kundensicht, die Validierung.

180
00:22:32,360 --> 00:22:38,600
Ich meine, als Kunde, da gehe ich mal davon aus, dass das, was ich da angeboten bekomme, wofür ich

181
00:22:38,600 --> 00:22:45,280
bezahlt habe, dass das richtig entwickelt wurde. Sprich, dass das Produkt funktioniert. Aber,

182
00:22:45,280 --> 00:22:51,640
das ist, ich sag mal, eine notwendige Voraussetzung oder eine Minimalforaussetzung. Viel wichtiger ist

183
00:22:51,640 --> 00:22:59,520
für mich als Nutzer, aber ist das denn valide? Das heißt, sind denn die Anforderungen, die ich

184
00:22:59,520 --> 00:23:06,640
als Kunde habe, erfüllt worden? So, bei der Validierung, da ist also die Einbeziehung des

185
00:23:06,640 --> 00:23:15,280
Kunden oder des Nutzers notwendig. Ja, da brauche ich also sowohl die Systemanalyse als auch die

186
00:23:15,280 --> 00:23:21,880
Spekation, Spezifikation und das Endprodukt. Und hier geht es um die Frage, wurde das richtige

187
00:23:21,880 --> 00:23:28,560
System entwickelt? Ja, es kann ja funktionieren, aber wenn ich in meiner Vermögensverwaltung dann

188
00:23:28,560 --> 00:23:36,400
die Immobilien nicht richtig erfassen kann, na dann kann ich das vielleicht nicht richtig benutzen.

189
00:23:36,400 --> 00:23:43,480
Oder wurde etwa nicht unterschieden zwischen Aktienwertpapieren und festverzinslichen

190
00:23:43,480 --> 00:23:48,720
Wertpapieren. Diese Dinge haben sehr unterschiedliche Datenstrukturen, wenn man sie erfassen möchte.

191
00:23:48,720 --> 00:23:53,080
Wenn ich eines davon nicht erfassen kann, na dann kann ich meine Vermögensverwaltung nicht richtig

192
00:23:53,080 --> 00:24:04,120
verwenden. Ja, genauso Beispiele ließen sich finden für die Projektbeantragung. Ja, oder fehlen bei

193
00:24:04,200 --> 00:24:11,200
der Vermögensverwaltung etwa die Grafiken. Dann kann ich keine Struktur meines Vermögens analysieren.

194
00:24:11,200 --> 00:24:18,360
Das sind dann die Fragen, die gehen dahin, kann der Nutzer mit dem, was da entwickelt worden ist,

195
00:24:18,360 --> 00:24:28,560
tatsächlich was anfangen? Und wenn das bejaht werden kann, dann ist das Produkt valide. Dann

196
00:24:28,560 --> 00:24:38,120
kann man mit dem Produkt richtig arbeiten. Immer, als wenn eine Bachelorarbeit wäre, ein Ergebnis,

197
00:24:38,120 --> 00:24:46,200
wenn Sie da ein Softwareprodukt erstellt haben, da sollten Sie immer validieren. Verifizieren

198
00:24:46,200 --> 00:24:52,680
natürlich auch, aber in dem gleichen Sinne, wie eben gesagt, dass ein Produkt funktioniert. Na,

199
00:24:52,680 --> 00:24:58,520
da gehen wir mal von aus, dass Sie da selbstständig genug dann gearbeitet und geprüft und getestet

200
00:24:58,520 --> 00:25:06,320
haben, dass das System richtig entwickelt worden ist. Aber dass der Benutzer damit auch was anfangen

201
00:25:06,320 --> 00:25:19,280
kann, das ist die wichtige Aussage und die zentrale Aussage. Und ja, wenn das eben nicht der Fall ist,

202
00:25:19,280 --> 00:25:24,640
dann landet im einfachsten Fall so ein Produkt nur im Schrank, wird also nicht weiter benutzt.

203
00:25:24,640 --> 00:25:31,240
Im schlimmsten Fall gibt es Rechtsstreitereien, ob da jemand dafür bezahlt. So, ordnen wir die

204
00:25:31,240 --> 00:25:39,960
Tests mal in den Softwareentwicklungsprozess ein. Wir haben ja mal diesen Softwareentwicklungsprozess

205
00:25:39,960 --> 00:25:48,760
gehabt in der folgenden Struktur. Vorstudie und Anforderungsanalyse, das Grobdesign mit der

206
00:25:48,760 --> 00:25:54,240
Komponentenbildung. Dann kommt die iterativ inkrementelle Entwicklung und Systemtest und

207
00:25:54,240 --> 00:26:00,760
Einführung. So, und diese beiden Schritte hier, iterativ inkrementelle Entwicklung und Systemtest,

208
00:26:00,760 --> 00:26:12,160
da ist das, wo man spätestens mit Tests beginnen sollte. So, wie testet man denn einfach? Ja,

209
00:26:12,160 --> 00:26:19,040
da sollte man auch wieder möglichst systematisch vorgehen. Das heißt, ein Test planen, dann muss

210
00:26:19,040 --> 00:26:24,280
der Test vorbereitet werden. Er muss dann wirklich durchgeführt werden und das Ergebnis muss

211
00:26:24,280 --> 00:26:29,200
dargestellt werden. Ich spreche hier jetzt nicht mehr von kleinen Tests, ob jetzt irgendeine Methode

212
00:26:29,200 --> 00:26:38,920
funktioniert, sondern wirklich von der Validierung, dass das Produkt also das tut, was es tun soll.

213
00:26:38,920 --> 00:26:46,000
So, und da gibt es jetzt innerhalb der Testplanung und Vorbereitung ein paar Dinge, mit denen sollte

214
00:26:46,000 --> 00:26:51,000
man sich auseinandersetzen. Da gibt es erstmal den Testrahmen. Da werden die Rahmenbedingungen

215
00:26:51,000 --> 00:26:58,880
für die Durchführung festgelegt. Die Kriterien für Start und Ende eines Testlaubs. In einem

216
00:26:58,880 --> 00:27:04,960
Meilenstein wird eine gewisse Funktionalität definiert. Ja, und da hängen dann Start und

217
00:27:04,960 --> 00:27:12,360
Ende in Mitteln. Welche Kriterien gibt es, sodass man sagen kann, ein Test ist gelungen oder hat

218
00:27:12,360 --> 00:27:18,120
auch nicht funktioniert? Dazu gehören Fragen, ja, was soll denn getestet werden? Wie detailliert,

219
00:27:18,120 --> 00:27:25,640
also welche Granularität soll denn bei den Tests an den Tag gelegt werden? Was sind so Ergebnisse,

220
00:27:25,640 --> 00:27:32,720
die wir hier erwarten? Ja, und wie sehen die Endprodukte eines Tests aus und die

221
00:27:32,720 --> 00:27:38,160
Kommunikationswege? Das heißt genauer, wie werden denn Fehler überhaupt dokumentiert? Das kann zum

222
00:27:38,160 --> 00:27:44,600
Beispiel in einem schriftlichen Bericht sein. Wie werden Fehler kategorisiert? Eine Kategorisierung

223
00:27:44,600 --> 00:27:52,080
kann man über Prioritätsstufen herbeiführen. Prioritätsstufen heißt, welcher Fehler muss als

224
00:27:52,080 --> 00:27:57,400
erstes beseitigt werden und welcher ist mehr kosmetischer Art. Muss also zunächst mal noch

225
00:27:57,400 --> 00:28:06,040
nicht eingegangen werden. Ja, und wer erhält denn welche Testergebnisse? Die Entwickler oder der

226
00:28:06,040 --> 00:28:12,600
Projektleiter oder vielleicht noch andere Personen? Ja, im Testrahmen muss man sich dann überlegen,

227
00:28:12,600 --> 00:28:19,440
welche Art von Tests werden denn durchgeführt, mit welchen Methoden wird getestet? Ja, und dann

228
00:28:19,440 --> 00:28:25,160
muss natürlich auch die Testplattform konfiguriert werden. Das heißt, dazu müssen Anforderungen an

229
00:28:25,160 --> 00:28:33,120
die Art und Software festgelegt werden, einschließlich der Systemumgebung. In der

230
00:28:33,120 --> 00:28:38,520
Regel setzt man dafür ja dann irgendein Testsystem auf, was noch nicht produktiv ist,

231
00:28:38,520 --> 00:28:44,600
um da nicht im schlechten Fall irgendwelchen Schaden anzurichten. Ja, und die Testdaten müssen

232
00:28:44,600 --> 00:28:52,120
spezifiziert werden. Irgendwoher brauche ich vielleicht auch mal ein paar Daten für meinen

233
00:28:52,120 --> 00:29:06,520
Tests. So, dann muss ich mich weiter damit befassen, welche Teststrategie möchte ich

234
00:29:06,520 --> 00:29:16,520
denn verfolgen. Ja, dazu gehört insbesondere, welche Testsziele möchte ich denn mir stecken.

235
00:29:16,520 --> 00:29:24,920
Zum Beispiel brauche ich einen korrekten Zugriff auf die Datenbasis. Wie sieht es mit einer

236
00:29:24,920 --> 00:29:32,760
Fehlerfindungsreiter aus? Mit einem schnellen Test, wie halte ich den Aufwand da gering oder will

237
00:29:32,760 --> 00:29:37,800
ich da mehr investieren? Da muss ich mir rechtzeitig darüber Gedanken machen, unter Umständen mit dem

238
00:29:37,800 --> 00:29:44,440
Kunden auch absprechen oder zumindest muss ich mit dem Budget das in Einklang bringen mit den

239
00:29:44,520 --> 00:29:52,720
Anzahl Personentagen, die ich für so einen Test einplane. Und wenn ich das weiß, kann ich

240
00:29:52,720 --> 00:30:02,080
entsprechend Antworten geben, wie intensiv teste ich denn, wie viel Aufwand stecke ich da rein.

241
00:30:02,080 --> 00:30:10,320
Ja, natürlich muss ich mir dann auch klar werden, wie führe ich die Tests durch, was die

242
00:30:10,320 --> 00:30:16,960
Wiederholbarkeit von Tests angeht, wenn der nicht wiederholbar ist. Ja, dann ist das so mit der

243
00:30:16,960 --> 00:30:23,840
Absicherung des Testergebnisses so eine Sache. Wenn ich einen Test zweimal mache, muss auch beide

244
00:30:23,840 --> 00:30:32,000
mal der gleiche Fehler herauskommen. So, ja, und welche Anforderungen an die Tester stelle ich denn?

245
00:30:32,000 --> 00:30:38,480
Wir haben, ist zwar ein etwas anderes Thema, kann man hier aber durchaus übertragen, bei der

246
00:30:38,480 --> 00:30:44,760
Dokumentation auch mal über verschiedene Adressaten gesprochen. Da haben wir unterschieden, sind das

247
00:30:44,760 --> 00:30:52,520
wenig Nutzer, sind das Experten. Solche Kriterien kann man hier auch anlegen bei den Testzielen.

248
00:30:52,520 --> 00:30:58,040
Wen brauche ich denn, um meine Testziele zu erreichen? Möchte ich da eben so ein wenig Nutzer oder so ein

249
00:30:58,040 --> 00:31:07,920
Experten hier in den Test einbeziehen? Ja, die dazu passende Teststrategie muss ich definieren,

250
00:31:07,920 --> 00:31:13,560
das heißt, ich muss Prioritäten von Testfällen setzen, da ich, wir haben ja vorhin schon gesagt,

251
00:31:13,560 --> 00:31:19,320
man kann nicht bei einem großen Produkt alle möglichen Anwendungsfälle durchtesten. Das heißt

252
00:31:19,320 --> 00:31:24,840
also auch hier muss ich Testfälle priorisieren. Da kann ich einerseits in meinen Use Cases hineinschauen,

253
00:31:24,840 --> 00:31:31,840
das sind ideale Quellen für Test Cases, aber insbesondere, wenn ich so eine Priorisierung vornehme,

254
00:31:31,840 --> 00:31:38,720
da sollte ich mich natürlich auch den Kunden orientieren. Was haben die für Wünsche, was ist

255
00:31:38,720 --> 00:31:45,400
für die Kunden am wichtigsten? Das sollte auf jeden Fall mal funktionieren und das sollte gut

256
00:31:45,400 --> 00:31:53,200
untersucht sein. Ja, die ebenso gehört dann dazu die Testreihenfolge der Qualitäten des Systems,

257
00:31:53,200 --> 00:31:59,160
da kann man ja noch ein bisschen weitergehen, hat so ein bisschen damit zu tun, was sind die Kunden

258
00:31:59,160 --> 00:32:04,160
Wünsche. Da können Vermarktungsaspekte dann aber auch noch eine Rolle spielen, was ist mir wichtig,

259
00:32:04,160 --> 00:32:13,880
was ich von meinem Produkt erzählen möchte und was es alles können soll und ja, das kann ich dann

260
00:32:13,880 --> 00:32:23,280
eben auch entsprechend höher priorisieren. Ja, zu den Qualitätsprioritäten, denn da gehören dann

261
00:32:23,280 --> 00:32:31,080
ja, Korrektheitssicherheit, die Performance, was jetzt die eine schnelle Entwicklung angeht,

262
00:32:31,080 --> 00:32:38,000
das heißt eine baldige Verfügbarkeit, all dazu muss ich mir im Vorfeld Gedanken machen und klar

263
00:32:38,000 --> 00:32:45,800
sagen, worauf lege ich hier welchen Wert. Wie sieht es mit dem Aufwand aus, mit dem Deckungsgrad,

264
00:32:45,800 --> 00:32:56,280
mit Anforderungen, ja und mit der Flexibilität auch, falls sich Anforderungen durchaus mal ändern.

265
00:32:56,280 --> 00:33:07,360
So, der Testgegenstand und die Testfälle. Ja, das muss man natürlich immer pro Produkt

266
00:33:07,360 --> 00:33:17,520
oder Teilprodukt angeben. Das heißt, die zu testenden Systeme oder Teilsysteme auf Klassenebene,

267
00:33:17,520 --> 00:33:24,560
naja, wenn ich sehr fein Granular testen möchte auch das. Ja, und dann muss ich angeben, was sind

268
00:33:24,560 --> 00:33:31,400
denn die zu testenden Eigenschaften. Ja, will ich jetzt einen Anwendungsfall testen oder bei

269
00:33:31,400 --> 00:33:40,880
detaillierter Granularität, welche Methode will ich testen, will ich in Algorithmus oder sowas

270
00:33:40,880 --> 00:33:51,520
gar testen. Ja, unter Umständen kann man hier auch durchaus abgrenzen und sagen, so, welche

271
00:33:51,520 --> 00:33:57,120
Eigenschaften unter Umständen nicht getestet werden sollen, das hängt dann eben von der

272
00:33:57,120 --> 00:34:03,400
Priorisierung ab, wenn die Ressourcen, die für einen Test zur Verfügung stehen, eben sehr

273
00:34:03,400 --> 00:34:13,000
eingeschränkt sind. Ja, die Auflistung der einzelnen Testfälle, das ist eigentlich so das, was hinterher

274
00:34:13,000 --> 00:34:20,040
dabei rauskommt und was sich auch immer ganz gut macht im Projekt und Abschlussarbeiten, wenn man

275
00:34:20,040 --> 00:34:28,840
kundtut, was hat man denn alles getestet, was, ja, wollte man testen und was war erwartet worden,

276
00:34:28,840 --> 00:34:35,960
was tatsächlich ausgekommen. So, und da macht man detaillierte Angaben zu Testrahmen und Teststrategie

277
00:34:35,960 --> 00:34:44,120
und zwar für jeden Testfall. Den Zeitplan darf man nicht vergessen, wenn man Tests plant und

278
00:34:44,120 --> 00:34:52,320
vorbereitet, eine detaillierte zeitliche Planung ist dazu notwendig, die Termine für die Tests,

279
00:34:52,320 --> 00:35:03,400
die Zeiten für Vor- und Nachbereitung. Ja, und so ein Testzeitplan, der gibt eben oder Projektzeitplan,

280
00:35:03,400 --> 00:35:13,520
der gibt den Rahmen vor, wann getestet werden soll. Der Testzeitplan, der ist allerdings wesentlich

281
00:35:13,520 --> 00:35:24,840
detaillierter als ein Projektzeitplan, der enthält eben spezifische Informationen über Testaktivitäten,

282
00:35:24,840 --> 00:35:35,440
die für den Projektablauf an sich noch irrelevant wären, die aber für den Testablauf wichtig sind.

283
00:35:35,440 --> 00:35:43,280
So, Zusammenfassung im Testplan, da kann man also sagen, die Ziele, da geht es darum, was soll

284
00:35:43,280 --> 00:35:50,200
erreicht werden, beim Umfang, was soll getestet werden, bei den Methoden, wie soll getestet werden,

285
00:35:50,200 --> 00:35:57,360
bei den Ressourcen, ja, wer testet, mit welchen Werkzeugen. Ja, und der Zeitplan ist einfach, wann

286
00:35:57,360 --> 00:36:09,880
wird getestet und die Verantwortlichkeit, wer ist für was zuständig. So, wenn man getestet hat,

287
00:36:09,880 --> 00:36:17,120
hatten wir ja vorhin schon gesagt, da ist es wichtig festzuhalten, was dabei rausgekommen ist

288
00:36:17,120 --> 00:36:23,040
und wie mit diesen Ergebnissen weiter umgegangen wird. Das heißt, wir müssen hergehen, erstmal

289
00:36:23,040 --> 00:36:31,720
ein Testprotokoll erstellen. Bestandteile dessen ist einerseits, ja, da sollte man sagen, um welchen

290
00:36:31,720 --> 00:36:41,080
Testfall handelt es sich bei diesem Protokoll. Wie sieht die Einzeltestfallspezifikation aus?

291
00:36:41,080 --> 00:36:48,120
Das kann sein, wenn man da so einen Test hat, da habe ich die Frau Meier als Testkandidatin,

292
00:36:48,120 --> 00:36:57,080
also als Person, als Mitarbeiterin, die das neue Produkt testet, die also nicht selbst getestet wird,

293
00:36:57,080 --> 00:37:04,880
sondern aktiv selbst testet. Ja, da sollte ich in so einem Protokoll etwas sagen, wer war das,

294
00:37:04,880 --> 00:37:09,680
wann war das, wo wurde das durchgeführt. Solche Tests kann man ja im Hause des Kunden machen,

295
00:37:09,680 --> 00:37:15,480
sowas kann man aber durchaus auch, ja, vielleicht im Hause der Entwicklungsformer machen. Hängt

296
00:37:15,480 --> 00:37:22,880
etwas von den Örtlichkeiten und den Beziehungen zwischen Kunden und Auftragenehmern ab. Ja,

297
00:37:22,880 --> 00:37:31,520
gibt es Abhängigkeiten zwischen den Testfällen? Welche Aufgaben hat die also bearbeitet? Das

298
00:37:31,520 --> 00:37:39,400
wäre hier noch die Testfälle-Identifikation oder die Einzelfallspezifikation. Welche Voraussetzungen

299
00:37:39,400 --> 00:37:45,280
sind an die Umgebung gestellt, in der da getestet wird? Ist das eine normale Büroumgebung? Ist das

300
00:37:45,280 --> 00:37:53,520
eine großhafte Umgebung? Oder, ja, je nachdem, wer das ist und was das für eine Applikation ist.

301
00:37:53,520 --> 00:37:57,760
Wir haben da auch so eine Applikation im Hause, die wird von Hausmeistern benutzt. Da habe ich

302
00:37:57,760 --> 00:38:04,640
mal eine ganz andere Umgebung. Da können Teile von der Software auch mal durchaus im Keller

303
00:38:04,640 --> 00:38:12,160
benutzt werden, wenn die da in irgendwelchen Geräten irgendwas ablesen müssen und da eine

304
00:38:12,160 --> 00:38:19,840
Software haben, die halt abgelesene Messwerte erfasst oder wo Fehlerberichte mal kurz geschrieben

305
00:38:19,840 --> 00:38:29,960
werden. Stichpunkte hier in der Heizung, der Öltank leckt oder irgend sowas. Das kann man unter

306
00:38:29,960 --> 00:38:37,600
Umständen dann sofort lokal aufnehmen und ja in das Produkt dann weiter einschließen lassen.

307
00:38:38,560 --> 00:38:47,360
Hier ist also gut zu protokollieren, wer hat was wann getestet. So, und diese Protokolle,

308
00:38:47,360 --> 00:38:54,400
die werden dann anschließend zusammengefasst in einen Testbericht, da werden die Fehlersituationen

309
00:38:54,400 --> 00:39:11,000
beurteilt, die Gesamtsituation kommentiert. Ja, das ist sozusagen das Ergebnis. Die Testmethoden,

310
00:39:11,000 --> 00:39:17,720
da haben wir so eine gewisse Palette Blackbox-Test, Whitebox-Test. Da möchte ich hier an dieser

311
00:39:17,720 --> 00:39:40,920
Stelle nicht mehr drauf eingehen, sondern hier noch auf unterschiedliche Varianten von Tests

312
00:39:40,920 --> 00:39:49,160
eingehen. Mal ganz kurz, und zwar zum einen kann man hergehen, Konfigurationen eines Systems

313
00:39:49,160 --> 00:39:56,000
überprüfen und da geht es einfach um die Lauffähigkeit des Systems auf einer Zielplattform.

314
00:39:56,000 --> 00:40:03,080
Auf einer Zielplattform, das heißt sie haben irgendwie entwickelt auf ihrem PC und entweder

315
00:40:03,080 --> 00:40:08,440
muss das jetzt in einer Arbeitsumgebung stattfinden auf einem größeren Rechner oder aber auch auf einem

316
00:40:08,440 --> 00:40:14,080
lokalen Device. Ja, der wichtige Unterschied ist, der meistens ist oder oftmals ist die

317
00:40:14,080 --> 00:40:22,240
Entwicklungsplattform ungleich der produktiven Plattform, wo das Produkt benutzt wird. Und da

318
00:40:22,240 --> 00:40:28,120
muss man eben sehen, auch wenn man eigentlich auf der Entwicklungsplattform alles so schön rund

319
00:40:28,120 --> 00:40:37,560
funktionierend hat, das muss auf der Zielplattform gar nicht so der Fall sein. Ja, was man dann auch

320
00:40:37,560 --> 00:40:44,000
testen sollte, ist die Installation, ist eine problemlose Installation auf dem Zielsystem möglich?

321
00:40:44,000 --> 00:40:52,920
Wie funktioniert das? Wie bringe ich meine entwickelte Produktfassung auf mein Zielsystem?

322
00:40:52,920 --> 00:40:59,800
Geht das über den Play Store oder das ist eine einfache Sache? Bei größeren Rechnersystemen gibt

323
00:40:59,800 --> 00:41:07,400
es auch entsprechende Verfahren, aber da muss ich eben schauen, habe ich hier alle Schritte berücksichtigt

324
00:41:07,400 --> 00:41:14,200
um mein Produkt hier in Betrieb nehmen zu können. Ja, der Funktionstest, das ist halt der Test erfüllt,

325
00:41:14,200 --> 00:41:20,560
das System die Anforderungen laut Anforderungsbeschreibung. Dann haben wir so einen Leistungstest, da

326
00:41:20,560 --> 00:41:28,960
geht es ja unter Realbedingungen soweit konstruierbar darum, wie werden die Ressourcen ausgelastet,

327
00:41:28,960 --> 00:41:35,240
wie sind die Antwortzeiten, wie ist das Lastverhalten, wenn ich da viele Leute vorsetze,

328
00:41:35,240 --> 00:41:45,680
viele Nutzer oder wenn Nutzer viele Transaktionen halt durchführen. So, hier muss man das erwartete

329
00:41:45,680 --> 00:41:51,360
Verhalten für jeden Einzelfall genau beschreiben und dann die Abweichungen entsprechend dokumentieren.

330
00:41:51,360 --> 00:42:00,480
Ja, Benutzbarkeitstests, hier kann man überprüfen, ist das unter ergonomischen Gesichtspunkten so

331
00:42:00,560 --> 00:42:09,040
etwas oder gut verwendbar. Das ist bereits in sehr frühen Entwicklungsphasen, wenn sie so horizontale

332
00:42:09,040 --> 00:42:15,400
Prototypen angefertigt haben, bereits möglich. Ja, das könnte ein eigenes Teilprojekt sogar sein,

333
00:42:15,400 --> 00:42:21,640
die Software Usability. Wenn man sowas zu einem späten Zeitpunkt macht, dann ist man meistens nur

334
00:42:21,640 --> 00:42:26,120
noch in der Lage somarisch zu beurteilen, eben wie vorhin gesagt, weil das Produkt schon sehr

335
00:42:26,120 --> 00:42:33,920
weit entwickelt ist und größere Änderungen, dann sehr viel Aufwand durchführen. Ja, Sicherheitstests

336
00:42:33,920 --> 00:42:42,520
gegebenenfalls durchführen, je nachdem welche Sicherheitsanforderungen davorliegen. Interoperabilitätstests,

337
00:42:42,520 --> 00:42:51,560
damit darunter versteht man so Schnittstellen zu anderen Systemen, gerade bei Kommunikationsprodukten.

338
00:42:51,560 --> 00:42:57,680
Ja, und wie sieht denn das aus? Und das vergisst man leicht, wenn so ein größeres Produkt, wo viele

339
00:42:57,680 --> 00:43:05,760
daran arbeiten, mal komplett abgeschaltet werden müssen. Also Neustart, wie einfach ist der möglich?

340
00:43:05,760 --> 00:43:12,200
Wenn wir jetzt alle für unseren Desktop-PC sitzen, ist das eine Trivialität. Aber wie ist das,

341
00:43:12,200 --> 00:43:17,600
wenn ich da jetzt mal 500 User habe, über Deutschland verteilt, ist das dann auch noch

342
00:43:17,600 --> 00:43:25,720
so einfach möglich? Sollte man bei einem systematisch durchgeführten Test auch mit

343
00:43:25,720 --> 00:43:32,160
berücksichtigen. Ja, und die Regulationstests, das sind also die Tests, wo immer wieder bereits

344
00:43:32,160 --> 00:43:42,000
durchgeführte Tests nochmal ausgeführt werden, aber ergänzt um Tests für neue Features, die

345
00:43:42,000 --> 00:43:52,400
sollte man immer wieder laufen lassen. So, damit habe ich die Thematik des Tests oder des Testens

346
00:43:52,400 --> 00:44:00,920
innerhalb des Software-Engineerings angesprochen. Man könnte zum Thema Software-Engineering oder

347
00:44:00,920 --> 00:44:06,560
zum Thema Test innerhalb des Software-Engineerings oder Qualitätssicherung eine eigene

348
00:44:06,560 --> 00:44:11,760
Lehrveranstaltung machen und deutlich tiefer drin einsteigen. Hier in dieser Veranstaltung

349
00:44:11,760 --> 00:44:18,160
ging es ja darum, den Software-Entwicklungsprozess von den Requirements bis zur Fertigstellung anzusprechen

350
00:44:18,160 --> 00:44:27,280
in allen Detailfassetten und da ist das Testen nur eine Facette. Wenn wir uns oder wenn Sie sich mit

351
00:44:27,280 --> 00:44:37,000
dem Testen weiter befassen möchten, dann kann man das in so Veranstaltungen, Vertiefungen des

352
00:44:37,000 --> 00:44:44,360
Software-Engineerings durchaus machen. Da geht man dann sehr ausführlich darauf ein.

