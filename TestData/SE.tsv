start	end	text
0	8520	So, im letzten Kapitel der Vorlesung Software Engineering 1 oder Einführung in der Software
8520	18680	Engineering dreht es sich um das Thema Software Test. Ja, schauen wir uns mal an, welche Probleme
18680	25120	gibt es mit Software Tests. Wir hatten ja schon mal zwei oder eine ganze Reihe von Beispielen am
25120	31120	Anfang der Vorlesung, wo wir darüber gesprochen haben, ja, warum ist es überhaupt sinnvoll,
31120	39080	strukturiert an eine Softwareentwicklung heranzugehen. Da will ich mal zwei Beispiele
39080	47560	herausgreifen. 1979 ist zwar schon ein älteres Beispiel, aber war ziemlich teuer, sage ich mal,
47560	52840	einfach, hat deutliche Konsequenzen gehabt. Das ist ein sehr einprägsames Beispiel.
53320	64960	Der Steuercomputer einer Venus-Runde, der führte folgenden Befehl aus. Du3 i gleich 1.3. Ja,
64960	73720	dass die Du-Schleife ist in Vortran gleich bedeutend, um in einer geringfügig anderen
73720	79720	Syntax wie die Vorschleife in Java oder in anderen Programmiersprachen, also eine einfache
79840	88880	Zellschleife. So, also hier sollte einfach eine Schleife programmiert werden. Ja,
88880	105480	nur hier gab es ein kleines Problem. Die Zuweisung an sich war gültig. Anstelle von diesem Du können
105480	114840	sich so ein Vor vorstellen. Die 3, das kennzeichnet einfach die letzte Zeile des Schleifenkörpers.
114840	126200	Ja, und dann kommt die Schleifenbedingung i gleich 1.3. Das wurde erfolgreich kompiliert. Ja,
126200	132960	und dementsprechend wurde also kein Fehler festgestellt. Das Ganze lief und die Rakete
132960	138160	flog und ja, flog leider an ihrem Ziel vorbei. Sie können sich vorstellen,
138160	146680	paar Millionen Dollar sind da leider in Rauch oder aufgegangen bzw. ins Nirwana gegangen.
146680	155960	Der Punkt ist nämlich hier der, richtig wäre gewesen, hier sollte einfach eine Schleife
155960	164280	dreimal durchgelaufen werden und zwar mit den Werten i gleich 1, i gleich 2, i gleich 3. So,
164280	170360	und diese Schleife, die Schleifenanfang und Schleifenende wie in einer Vorschleife,
170360	182080	das wird hier eben so aufgezählt. Ja, Schleifenanfang und Schleifenende des Schleifenzählers.
182080	188640	Syntaktisch gültig ist das Ganze hier oben in Fortran, aber deswegen, Fortran ist eine
188640	195480	ältere Programmiersprache, wird teilweise noch genutzt. Ja, gültig ist das, weil man in Fortran
195480	208440	auch über Gleitkommawerte iterieren darf. Ja, da dürfte ich also von 1,3 bis 1,7 iterieren und
208440	215000	das hier wäre jetzt also einfach ein Schleifenanfang und als Schleifenanfang ist der
215000	223760	Wert 1,3 angegeben, also syntaktisch richtig. Ja, und wenn man sowas nicht ordentlich testet,
223760	236280	dann passiert halt schon mal größerer Schaden. Ein anderes Beispiel war der 1984 im Computer
236440	244240	meint, eine Überlaufgefahr für einen Staudamm in Frankreich zu erkennen und dementsprechend
244240	250440	öffnete er einfach mal zwei Schleusentore automatisch. Das führte zu einer Überschwemmung
250440	256520	und viele weitere Beispiele haben wir damals besprochen, auch aus der Neuzeit. Sie entsinnen
256520	261880	sich vor ein paar Jahren, da wurde eine Wahlbeteiligung von über 100 Prozent irgendwie
261880	268240	ermittelt, was ja nun auch keinen Sinn macht. Also auch da sind irgendwelche Prüfungen nicht
268240	276840	ordentlich gewesen. Ja, schauen wir uns mal weiter an, womit sollte man sich denn genauer befassen,
276840	283400	wenn es sich ums Testen handelt. Testen ist einfach nur ein kurzer Begriff, da kann man
283400	292360	was ganz eng abgegrenztes mitmeiden, dass man einfach ausprobiert ist, ein Programm laufig
292360	298520	oder aber man kann aber auch übergeordnete Prozesse darunter verstehen. Deswegen gehen
298520	304280	wir hier jetzt mal kurz auf andere Begriffe ein. Und zwar, Test hat ja immer was mit Qualität zu
304280	315440	tun. Und ja, dementsprechend sind in diesem Umfeld das Testen zu Begriffe üblich, die sich
315440	320880	mit Qualität befassen. Und schauen wir zuerst mal auf den Beruf des Qualitätsmanagements.
320880	329560	Darunter versteht man alle organisatorischen Maßnahmen oder Tätigkeiten und Maßnahmen zum
329560	336520	Leiten und Lenken einer Organisation bezüglich Qualität, sind also Tätigkeiten und Maßnahmen,
336520	343520	die da eine Rolle spielen. Dazu gehörten zum Beispiel die Festlegung von Qualitätszielen,
343520	350560	die Qualitätsplanung, die Qualitätssicherung oder auch die Qualitätsverbesserung. Das ist ein
350560	356160	zentraler Bestandteil von Arbeitsprozessen in ganz vielen Branchen. Qualitätsmanagement,
356160	363400	also in der Automobilindustrie ist das das A und O. Sie wissen, dass wir heutzutage sehr
363400	368480	hochwertige Automobile haben, aber diese Hochwertigkeit oder diese Wertigkeit bekommt
368480	375480	man nur durch ein angemessenes Qualitätsmanagement in den Kopf. In der Luftfahrtindustrie ebenso,
375480	383160	da spielt das Qualitätsmanagement nicht nur in den Komfortbereich hinein, sondern schlichtweg
383960	389400	in die Sicherheit. Das sind nur zwei Beispiele von Branchen. Es gibt, eigentlich soll ich da
389400	395600	drei Prümpchen hinter machen, noch ganz viele weitere Beispiele. Ab zur Ganzen vom Qualitätsmanagement
395600	402440	ist die Qualitätssicherung, das ist nämlich eigentlich nur ein Teil des Qualitätsmanagements,
402440	411200	wie sich hier oben auch ausdrückt. Hier oben habe ich die Qualitätssicherung als Teil des
411200	417480	Qualitätsmanagements schon aufgeführt. Hierbei geht es einfach um die Einhaltung der vereinbarten
417480	424160	Arbeitsprozesse zur Vermeidung von Fehlerzuständen, also um die Analyse der Ursachen für Fehler.
424160	432360	Das Qualitätsmanagement dient der Erkennung, also dem Testen, unter Beseitigung von Fehlerzuständen.
432360	440360	Testen ist also eigentlich in diesem Sinne hier nur die Erkennung von Fehlerzuständen.
440360	447040	Ja, und ein Test ist also auch ein Mittel zur Erreichung eines angemessenen Qualitätsniveaus.
447040	457160	Ja, was wir also festhalten können ist, Test ist ungleich von Qualitätssicherung und eigentlich hätte
457160	462600	ich das hier auch noch erweitern können. Qualitätssicherung ist ungleich mit Qualitätsmanagement,
462600	468080	aber ich denke, dass es hier jetzt durch die Folie auch zum Ausdruck kommt. Welche Probleme
468080	475200	gibt es denn bei der Durchführung von Softwaretests? Wir befassen uns hier jetzt in dieser Stunde
475200	483040	natürlich nur mit dem enger eingegrenzten Begriff der Softwaretests. Und zum einen haben wir den
483040	491840	Aufwand. Bei komplexen Produkten gibt es da einen erhöhten Zeit- und Personalaufwand. Aber man sollte
491840	504240	gleich sich bewusst machen, wenn man hochwertige Produkte seriös entwickeln möchte, egal ob das
504240	509680	in der Automobilindustrie ist, Luftfahrt, die haben wir genannt, oder auch so Unternehmen wie Siemens,
509680	518880	also große Unternehmen oder auch Unternehmen wie SAP, die größere Softwareprodukte erstellen,
519000	527160	die leisten sich auch eigene Testabteilungen. Ich kenne das aus meinem eigenen Umfeld heraus auch.
527160	534960	Da bin ich Softwareentwicklungsabteilungen begegnet, die gar nicht so groß waren wie
534960	542440	jetzt so eine Siemens oder IBM oder SAP. Nee, das waren 30-40 Leute, aber die hatten eine kleine
542440	548400	Testabteilung für ihre Produkte schon installiert. Die bestand dann eben nur aus zwei Mitarbeitern.
548400	557160	Aber immerhin, der große Vorteil ist, wenn ich da eine eigene Abteilung rausmache, und das ist
557160	565280	vielleicht die wichtigste Aussage hierbei, dass Entwicklung und Test von verschiedenen Personen
565280	572800	ausgeführt werden sollten. Denn der Entwickler, das was man selbst entwickelt hat, das kennt man
572800	580400	einfach zu gut. Man hat einen gewissen Blickwinkel da drauf und denkt an verschiedene Konstellationen,
580400	585960	wie man das Produkt auch verwenden könnte, gar nicht. Und da ist es dann sehr praktisch,
585960	591720	wenn da jemand aus einem anderen Blickwinkel heraus rangeht und das dann eben nur testet. Der
591720	597200	hatte mit der Entwicklung gar nichts zu tun. Wie das mit welchen tollen Algorithmen gebaut worden
597200	602840	ist, ist untergeordnet. Der schaut nur danach, was ist das Ergebnis, was klappt vielleicht nicht.
602840	610640	Deswegen ist diese Trennung auf personaler Ebene da außerordentlich hilfreich und macht eben auch
610640	617560	schon bei kleinen Organisationseinheiten Sinn. Ja, weiteres Problem ist die destruktive Grundaufgabe
617560	626240	beim Testen. Ein Test dokumentiert bereits gemachte Fehler. Ja, in der eigenen oder eigene Fehler oder
626240	631320	in der eigenen Abteilung. Da kommt es eben auch nochmal drauf an, wenn das der Entwickler ist,
631320	636280	der selbst testet. Natürlich testet er immer seine einzelnen Methoden, seine einzelnen Unterprogramme,
636280	644960	aber so größere Tests, na ja, wer stellt schon gerne fest, was habe ich jetzt in größerem Stil
644960	651600	verkehrt gemacht. Das ist natürlich auch nicht so eine tolle Aufgabe, auch wenn das Umfeld
651600	662160	entsprechend geartet ist. So, das sind so zwei Problembereiche, wo man mal schnell dran denken
662160	667040	könnte, ach, hier kann man auch ein bisschen dran sparen. Na, war das einerseits zeitaufwendig und
667040	671560	damit personalaufwendig und na ja, eine schöne Aufgabe ist das auch nicht. Zumindest, wenn man
671560	680400	die eigenen Dinge testen soll. Aber daran zu sparen, da kann man nur vorwarnen, denn jedes
680400	687520	Produkt wird getestet. Immer. Nämlich spätestens vom Endbenutzer. Ja, und wenn der Endbenutzer das
687520	693360	testet und vorher zu wenig getestet worden ist, findet er vielleicht auch noch eine ganze Reihe
693360	699120	von Fehlern. Und dann ist mal die Frage zu stellen, wie sieht es denn dann mit dem Kundenvertrauen aus?
699120	708040	Also, da zu groß einzusparen, das sollte man sich sehr, sehr gut überlegen. Das macht ganz einfach
708040	715760	gesagt, vielleicht nur einen schlechten einen. Ja, und dann kommt noch eines hinzu, der Korrekturaufwand.
715760	723520	Je später hier etwas entdeckt wird, je größer ist der Korrekturaufwand. Ja, da die Entwicklung
723520	728000	oftmals schon abgeschlossen ist. Ja, stellen Sie sich vor, der Endbenutzer testet was oder man
728000	734800	testet etwas auch in der Testabteilung. Aber wenn die erst sehr spät ins Boot kommt, also ans Test
734800	739320	kommt, dann ist die Entwicklung oftmals schon abgeschlossen. Konzeptionelle Änderungen,
739320	744640	wo also im Ansatz irgendwie etwas schlecht überlegt worden ist oder einfach nicht bedacht
744640	750960	worden ist, konzeptionelle Änderungen sind dann natürlich nur noch sehr schwer durchzuführen. Und
750960	756760	ist das Produkt erst mal im Einsatz, na ja, dann bewirken kleine Änderungen großen Aufwand. Wenn
756760	762520	das Produkt im Einsatz ist, stellen Sie es mal vor, das ist jetzt mal eine Bank oder Versicherung im
762520	767920	Einsatz und da arbeiten mal so 3000 Leute mit einem Produkt. Wenn Sie da Änderungen durchführen
767920	775520	wollen, dann müssen Sie die allein mal distribuieren. Ja, an die entsprechenden Enduser bringen,
775520	782160	die vielleicht sogar schulen auf ein anderes Verhalten des Produkts. Das heißt also Änderungen im
782160	790600	Produkteinsatz. Da sollte man alles für tun, die zu vermeiden, obwohl letztendlich immer vermeiden
790760	798520	wird es nicht möglich sein. Ja, was sind so mögliche Fehlerquellen? Wir wissen ja alle
798520	805800	als Informatiker, keine Software ist fehlerfrei. Welche Fehlerquellen haben wir? Ja, eine fehlende
805800	812520	Kommunikation, das passiert zum Beispiel in der Teamkoordination, kann laufend passieren.
812520	822040	Sich ändern Anforderungen. Manchmal haben die Kunden die Auftraggeber halt, ja, noch zusätzliche
822040	828120	Ideen. Da ist in der Anforderungsermittlung in der Phase vielleicht irgendwas nicht ganz ideal
828120	835080	gelaufen. Zeitdruck kann so eine Fehlerquelle sein. Teammitglieder, weil die sich einfach, ja,
835080	842640	in den eingesetzten Technologien noch nicht sehr auskennen. Da ist ein Berufsanfänger drin,
842640	848480	der vielleicht in seiner Ausbildung Java gemacht hat und soll jetzt ein C++ Programm schreiben oder
848480	855120	sowas, was er nicht so gerne gelernt hat oder nicht gerne gemacht hat. Vielleicht ist der Code
855120	864200	einfach nur schlecht dokumentiert. Ja, oder bei den Entwicklungswerkzeugen der Arbeit ist etwas. Ja,
864320	872040	dann kommen ganz zuletzt die Programmierfehler, an die man schnell zuerst denkt, aber ich denke,
872040	881960	diese Liste hier zeigt, die Fehlerquellen sind viel, viel, ja, vielseitiger als jetzt nur irgendein
881960	890880	Programmierfehler wie bei dieser Buchleife. Ja, dementsprechend gibt es verschiedene Ebenen
890960	895560	der Durchführung der Qualitätssicherung. Wir haben auf der einen Seite die software spezifische Ebene.
895560	902360	Hier werden praktische Anwendungssituationen gegenübergestellt mit schriftlichen
902360	914360	Spezifikationen. Ja, und software spezifisch natürlich auch ist der Source Code. So, und das
914360	919480	sind Dinge, damit befasst man sich dann im Themenumfeld des Software-Engineering.
919480	925960	Organisationsspezifisch kann man natürlich auch Qualität sicherstellen. Da geht es dann aber mehr
925960	931000	um die Fragen der Projektorganisation und vielleicht der Schulung der Mitarbeiter.
931000	939200	Es gibt, wenn man sich so mit Qualitätssicherung im Software-Umfeld befasst, so sieben Grundsätze
939200	945320	des Testens. Die möchte ich Ihnen jetzt auf den nächsten beiden Folien einmal kurz vorstellen.
945320	953240	Ja, fangen wir mit dem ersten an. Testen zeigt die Anwesenheit von Fehlerzuständen.
953240	962080	Dass also die Situation nur ein Fehler eingetreten ist und das bewirkt halt einen Test. Und was man
962080	968680	versuchen möchte, ist die Reduktion der Wahrscheinlichkeit des Auftrittens weiterer
968680	974720	Fehler. Wenn man keinen Fehlerzustand gefunden hat, naja, dann heißt das aber nicht, dass die
974720	982040	Software fehlerfrei ist. Das ist unsere übliche Erfahrung von allen, die mal Software entwickelt
982040	989720	haben. Ja, ebenso in eine ähnliche Richtung geht ein vollständiges Testen ist unmöglich. Denken
989720	996080	Sie mal an so ein Produkt, was wir alle kennen, Sunworld oder vergleichbar von Konkurrenzprodukten.
996080	1007000	Wie viele hunderte von Funktionen gibt es darin? Die kann man nicht alle durchtesten. Manche
1007000	1011040	Funktionen werden nur sehr selten benutzt. Natürlich wird man sich auf die repräsentativen
1011040	1019320	Anwendungsfälle stürzen beim Test und sehr viel versuchen auszuprobieren, klappt das alles. Aber
1019320	1027540	vollständig heißt, jede einzelne Situation der Anwendung auszuprobieren, ist eigentlich nicht
1027540	1035840	möglich. Ja, dritter Grundsatz greift das auf, was ich gerade eben schon angesprochen habe,
1035840	1043080	frühes Testen, Sparzeit und Geld. Also nicht erst, wenn das Produkt fertig ist, sondern unter
1043080	1052040	Umständen zu sehr wohl überlegten Zeitpunkten innerhalb der Entwicklung bereits Tests einplanen.
1052040	1060000	Denken Sie an gerade so konzeptionelle Fehler, damit man die auch noch beheben kann. Häufung
1060000	1066640	von Fehlerzuständen. Fehlerzustände sind ungleichmäßig verteilt. Das heißt,
1066640	1072960	man hat unter Umständen Module, die sehr fehlerzustandsreich sind und die muss man
1072960	1084000	identifizieren und dort Tests intensivieren. Vorsicht vor dem Pestizidparadoxon. Alte Tests
1084000	1093520	verlieren ihre Wirkung zur Erkennung von Fehlerzuständen. Weiterentwickelte Programmteile
1093720	1101680	werden nämlich so nicht erfasst. Das heißt, man hat oder das meint, wenn man viele Tests auch
1101680	1105200	schon durchgeführt hat, man kann Tests ja durchaus automatisiert auch durchführen.
1105200	1112720	Da gibt es ja mittlerweile auch Tests, wo man sowas machen kann. Ja, wenn ich dann einfach die
1112720	1122560	bestehenden Tests nochmal automatisiert ablaufen lasse, dann habe ich zwar getestet,
1122560	1128360	aber ich habe meine Tests nicht auf neu entwickelte Programmteile angepasst. Die
1128360	1135440	werden also durch alte Tests nicht erfasst. Das heißt also, ich muss auch meine Tests,
1135440	1143400	die ich durchführe, immer wieder auf das Programm anpassen. Ja, Testen ist kontextabhängig. Wenn ich
1143400	1147480	nur Hotelbuchungen durchführen möchte. Jetzt bin ich auf einer Dienstreise und es hat sich
1147480	1155760	festgestellt, ich muss bei dem Kunden noch einen Tag länger bleiben. Ja, da gibt es dann
1155760	1161400	unterschiedliche Situationen. Entweder sitze ich bei dem Kunden noch im Büro und darf dessen Rechner
1161400	1167800	benutzen und kann dann am Desktop vielleicht mein Hotelzimmer für die eine Nacht buchen oder aber
1167800	1177200	ich bin schon unterwegs, sitze an der Bushaltestelle oder auf dem Bahnsteig und muss über
1177200	1189520	irgendwelche mobilen Devices mein Hotelzimmer reservieren. Ja, also das Prinzip ist der gleiche
1189520	1198040	Anwendungsfall, aber ich habe einen unterschiedlichen Kontext. Ja, und weiterer Grundsatz des Testens,
1198040	1206560	der letzte. Das ist ein Trugschluss. Keine Fehler gefunden bedeutet ein brauchbares System. Das ist
1206560	1218800	überhaupt nicht der Fall. Software-Tests sind immer Stichproben. Ja, und denken Sie auch daran,
1218800	1225200	Endnutzer, die können Erwartungen und Erfahrungen mit Alt- und Konkurrenzprodukten einbringen und
1225200	1232840	haben davon eben auch ihre eigene Zugänge oder Zugangsweise zu einem bestehenden Produkt. Jetzt
1232840	1244800	kann man Fehler kategorisieren. Ja, das möchte ich mal relativ kurz halten. Fehlerwirkung,
1244800	1251200	Fehlerhandlung, Fehlerzustand. Zustand ist, wenn der Fehler einfach nur vorliegt. Fehlerwirkung ist
1251200	1259200	das, was daraus wirklich gemacht wird. Schauen wir mal hier auf zwei Dinge, die mir besonders
1259200	1266160	wichtig sind bei den Testen von Software-Produkten. Da ist nämlich einerseits der Begriff der
1266160	1273600	Verifikation und andererseits der Validierung. So, und die Verifikation, dabei handelt es sich um
1273600	1282360	die Sicherstellung, dass alle Teilergebnisse von Projektentwicklungsphasen konsistent sind. Das
1282360	1287800	heißt, hier gleiche ich mein Softwareprodukt ab mit dem Pflichtenheft. Ich habe also eine Vorgabe
1287800	1295680	und prüfe, ist das jetzt richtig umgesetzt, was im Pflichtenheft drin steht? Sind die
1295680	1303800	funktionalen und nicht funktionalen Anforderungen von der Spezifikation richtig umgesetzt? Ja,
1303800	1312240	wurde also das System technisch richtig entwickelt. Das kann ich sogar machen, ohne dass ich anwende
1312240	1319480	einbeziehe. So, und denken wir mal an unsere Praktikumsaufgaben. Da haben wir ja diese
1319480	1328240	Vermögensverwaltung oder auch die Projektbeantragungssoftware und die Frage, die man hier stellen kann ist eben,
1328240	1337200	funktioniert die Vermögensverwaltung? Kann ich ein Projekt hier beantragen? Funktioniert das? Und das heißt,
1337200	1342440	das ist also die Frage hier zu stellen, wurde das System richtig entwickelt? Das ist die
1342440	1352360	Verifikation. Aber ganz wichtig ist aber auch, und zwar aus Nutzer, aus Kundensicht, die Validierung.
1352360	1358600	Ich meine, als Kunde, da gehe ich mal davon aus, dass das, was ich da angeboten bekomme, wofür ich
1358600	1365280	bezahlt habe, dass das richtig entwickelt wurde. Sprich, dass das Produkt funktioniert. Aber,
1365280	1371640	das ist, ich sag mal, eine notwendige Voraussetzung oder eine Minimalforaussetzung. Viel wichtiger ist
1371640	1379520	für mich als Nutzer, aber ist das denn valide? Das heißt, sind denn die Anforderungen, die ich
1379520	1386640	als Kunde habe, erfüllt worden? So, bei der Validierung, da ist also die Einbeziehung des
1386640	1395280	Kunden oder des Nutzers notwendig. Ja, da brauche ich also sowohl die Systemanalyse als auch die
1395280	1401880	Spekation, Spezifikation und das Endprodukt. Und hier geht es um die Frage, wurde das richtige
1401880	1408560	System entwickelt? Ja, es kann ja funktionieren, aber wenn ich in meiner Vermögensverwaltung dann
1408560	1416400	die Immobilien nicht richtig erfassen kann, na dann kann ich das vielleicht nicht richtig benutzen.
1416400	1423480	Oder wurde etwa nicht unterschieden zwischen Aktienwertpapieren und festverzinslichen
1423480	1428720	Wertpapieren. Diese Dinge haben sehr unterschiedliche Datenstrukturen, wenn man sie erfassen möchte.
1428720	1433080	Wenn ich eines davon nicht erfassen kann, na dann kann ich meine Vermögensverwaltung nicht richtig
1433080	1444120	verwenden. Ja, genauso Beispiele ließen sich finden für die Projektbeantragung. Ja, oder fehlen bei
1444200	1451200	der Vermögensverwaltung etwa die Grafiken. Dann kann ich keine Struktur meines Vermögens analysieren.
1451200	1458360	Das sind dann die Fragen, die gehen dahin, kann der Nutzer mit dem, was da entwickelt worden ist,
1458360	1468560	tatsächlich was anfangen? Und wenn das bejaht werden kann, dann ist das Produkt valide. Dann
1468560	1478120	kann man mit dem Produkt richtig arbeiten. Immer, als wenn eine Bachelorarbeit wäre, ein Ergebnis,
1478120	1486200	wenn Sie da ein Softwareprodukt erstellt haben, da sollten Sie immer validieren. Verifizieren
1486200	1492680	natürlich auch, aber in dem gleichen Sinne, wie eben gesagt, dass ein Produkt funktioniert. Na,
1492680	1498520	da gehen wir mal von aus, dass Sie da selbstständig genug dann gearbeitet und geprüft und getestet
1498520	1506320	haben, dass das System richtig entwickelt worden ist. Aber dass der Benutzer damit auch was anfangen
1506320	1519280	kann, das ist die wichtige Aussage und die zentrale Aussage. Und ja, wenn das eben nicht der Fall ist,
1519280	1524640	dann landet im einfachsten Fall so ein Produkt nur im Schrank, wird also nicht weiter benutzt.
1524640	1531240	Im schlimmsten Fall gibt es Rechtsstreitereien, ob da jemand dafür bezahlt. So, ordnen wir die
1531240	1539960	Tests mal in den Softwareentwicklungsprozess ein. Wir haben ja mal diesen Softwareentwicklungsprozess
1539960	1548760	gehabt in der folgenden Struktur. Vorstudie und Anforderungsanalyse, das Grobdesign mit der
1548760	1554240	Komponentenbildung. Dann kommt die iterativ inkrementelle Entwicklung und Systemtest und
1554240	1560760	Einführung. So, und diese beiden Schritte hier, iterativ inkrementelle Entwicklung und Systemtest,
1560760	1572160	da ist das, wo man spätestens mit Tests beginnen sollte. So, wie testet man denn einfach? Ja,
1572160	1579040	da sollte man auch wieder möglichst systematisch vorgehen. Das heißt, ein Test planen, dann muss
1579040	1584280	der Test vorbereitet werden. Er muss dann wirklich durchgeführt werden und das Ergebnis muss
1584280	1589200	dargestellt werden. Ich spreche hier jetzt nicht mehr von kleinen Tests, ob jetzt irgendeine Methode
1589200	1598920	funktioniert, sondern wirklich von der Validierung, dass das Produkt also das tut, was es tun soll.
1598920	1606000	So, und da gibt es jetzt innerhalb der Testplanung und Vorbereitung ein paar Dinge, mit denen sollte
1606000	1611000	man sich auseinandersetzen. Da gibt es erstmal den Testrahmen. Da werden die Rahmenbedingungen
1611000	1618880	für die Durchführung festgelegt. Die Kriterien für Start und Ende eines Testlaubs. In einem
1618880	1624960	Meilenstein wird eine gewisse Funktionalität definiert. Ja, und da hängen dann Start und
1624960	1632360	Ende in Mitteln. Welche Kriterien gibt es, sodass man sagen kann, ein Test ist gelungen oder hat
1632360	1638120	auch nicht funktioniert? Dazu gehören Fragen, ja, was soll denn getestet werden? Wie detailliert,
1638120	1645640	also welche Granularität soll denn bei den Tests an den Tag gelegt werden? Was sind so Ergebnisse,
1645640	1652720	die wir hier erwarten? Ja, und wie sehen die Endprodukte eines Tests aus und die
1652720	1658160	Kommunikationswege? Das heißt genauer, wie werden denn Fehler überhaupt dokumentiert? Das kann zum
1658160	1664600	Beispiel in einem schriftlichen Bericht sein. Wie werden Fehler kategorisiert? Eine Kategorisierung
1664600	1672080	kann man über Prioritätsstufen herbeiführen. Prioritätsstufen heißt, welcher Fehler muss als
1672080	1677400	erstes beseitigt werden und welcher ist mehr kosmetischer Art. Muss also zunächst mal noch
1677400	1686040	nicht eingegangen werden. Ja, und wer erhält denn welche Testergebnisse? Die Entwickler oder der
1686040	1692600	Projektleiter oder vielleicht noch andere Personen? Ja, im Testrahmen muss man sich dann überlegen,
1692600	1699440	welche Art von Tests werden denn durchgeführt, mit welchen Methoden wird getestet? Ja, und dann
1699440	1705160	muss natürlich auch die Testplattform konfiguriert werden. Das heißt, dazu müssen Anforderungen an
1705160	1713120	die Art und Software festgelegt werden, einschließlich der Systemumgebung. In der
1713120	1718520	Regel setzt man dafür ja dann irgendein Testsystem auf, was noch nicht produktiv ist,
1718520	1724600	um da nicht im schlechten Fall irgendwelchen Schaden anzurichten. Ja, und die Testdaten müssen
1724600	1732120	spezifiziert werden. Irgendwoher brauche ich vielleicht auch mal ein paar Daten für meinen
1732120	1746520	Tests. So, dann muss ich mich weiter damit befassen, welche Teststrategie möchte ich
1746520	1756520	denn verfolgen. Ja, dazu gehört insbesondere, welche Testsziele möchte ich denn mir stecken.
1756520	1764920	Zum Beispiel brauche ich einen korrekten Zugriff auf die Datenbasis. Wie sieht es mit einer
1764920	1772760	Fehlerfindungsreiter aus? Mit einem schnellen Test, wie halte ich den Aufwand da gering oder will
1772760	1777800	ich da mehr investieren? Da muss ich mir rechtzeitig darüber Gedanken machen, unter Umständen mit dem
1777800	1784440	Kunden auch absprechen oder zumindest muss ich mit dem Budget das in Einklang bringen mit den
1784520	1792720	Anzahl Personentagen, die ich für so einen Test einplane. Und wenn ich das weiß, kann ich
1792720	1802080	entsprechend Antworten geben, wie intensiv teste ich denn, wie viel Aufwand stecke ich da rein.
1802080	1810320	Ja, natürlich muss ich mir dann auch klar werden, wie führe ich die Tests durch, was die
1810320	1816960	Wiederholbarkeit von Tests angeht, wenn der nicht wiederholbar ist. Ja, dann ist das so mit der
1816960	1823840	Absicherung des Testergebnisses so eine Sache. Wenn ich einen Test zweimal mache, muss auch beide
1823840	1832000	mal der gleiche Fehler herauskommen. So, ja, und welche Anforderungen an die Tester stelle ich denn?
1832000	1838480	Wir haben, ist zwar ein etwas anderes Thema, kann man hier aber durchaus übertragen, bei der
1838480	1844760	Dokumentation auch mal über verschiedene Adressaten gesprochen. Da haben wir unterschieden, sind das
1844760	1852520	wenig Nutzer, sind das Experten. Solche Kriterien kann man hier auch anlegen bei den Testzielen.
1852520	1858040	Wen brauche ich denn, um meine Testziele zu erreichen? Möchte ich da eben so ein wenig Nutzer oder so ein
1858040	1867920	Experten hier in den Test einbeziehen? Ja, die dazu passende Teststrategie muss ich definieren,
1867920	1873560	das heißt, ich muss Prioritäten von Testfällen setzen, da ich, wir haben ja vorhin schon gesagt,
1873560	1879320	man kann nicht bei einem großen Produkt alle möglichen Anwendungsfälle durchtesten. Das heißt
1879320	1884840	also auch hier muss ich Testfälle priorisieren. Da kann ich einerseits in meinen Use Cases hineinschauen,
1884840	1891840	das sind ideale Quellen für Test Cases, aber insbesondere, wenn ich so eine Priorisierung vornehme,
1891840	1898720	da sollte ich mich natürlich auch den Kunden orientieren. Was haben die für Wünsche, was ist
1898720	1905400	für die Kunden am wichtigsten? Das sollte auf jeden Fall mal funktionieren und das sollte gut
1905400	1913200	untersucht sein. Ja, die ebenso gehört dann dazu die Testreihenfolge der Qualitäten des Systems,
1913200	1919160	da kann man ja noch ein bisschen weitergehen, hat so ein bisschen damit zu tun, was sind die Kunden
1919160	1924160	Wünsche. Da können Vermarktungsaspekte dann aber auch noch eine Rolle spielen, was ist mir wichtig,
1924160	1933880	was ich von meinem Produkt erzählen möchte und was es alles können soll und ja, das kann ich dann
1933880	1943280	eben auch entsprechend höher priorisieren. Ja, zu den Qualitätsprioritäten, denn da gehören dann
1943280	1951080	ja, Korrektheitssicherheit, die Performance, was jetzt die eine schnelle Entwicklung angeht,
1951080	1958000	das heißt eine baldige Verfügbarkeit, all dazu muss ich mir im Vorfeld Gedanken machen und klar
1958000	1965800	sagen, worauf lege ich hier welchen Wert. Wie sieht es mit dem Aufwand aus, mit dem Deckungsgrad,
1965800	1976280	mit Anforderungen, ja und mit der Flexibilität auch, falls sich Anforderungen durchaus mal ändern.
1976280	1987360	So, der Testgegenstand und die Testfälle. Ja, das muss man natürlich immer pro Produkt
1987360	1997520	oder Teilprodukt angeben. Das heißt, die zu testenden Systeme oder Teilsysteme auf Klassenebene,
1997520	2004560	naja, wenn ich sehr fein Granular testen möchte auch das. Ja, und dann muss ich angeben, was sind
2004560	2011400	denn die zu testenden Eigenschaften. Ja, will ich jetzt einen Anwendungsfall testen oder bei
2011400	2020880	detaillierter Granularität, welche Methode will ich testen, will ich in Algorithmus oder sowas
2020880	2031520	gar testen. Ja, unter Umständen kann man hier auch durchaus abgrenzen und sagen, so, welche
2031520	2037120	Eigenschaften unter Umständen nicht getestet werden sollen, das hängt dann eben von der
2037120	2043400	Priorisierung ab, wenn die Ressourcen, die für einen Test zur Verfügung stehen, eben sehr
2043400	2053000	eingeschränkt sind. Ja, die Auflistung der einzelnen Testfälle, das ist eigentlich so das, was hinterher
2053000	2060040	dabei rauskommt und was sich auch immer ganz gut macht im Projekt und Abschlussarbeiten, wenn man
2060040	2068840	kundtut, was hat man denn alles getestet, was, ja, wollte man testen und was war erwartet worden,
2068840	2075960	was tatsächlich ausgekommen. So, und da macht man detaillierte Angaben zu Testrahmen und Teststrategie
2075960	2084120	und zwar für jeden Testfall. Den Zeitplan darf man nicht vergessen, wenn man Tests plant und
2084120	2092320	vorbereitet, eine detaillierte zeitliche Planung ist dazu notwendig, die Termine für die Tests,
2092320	2103400	die Zeiten für Vor- und Nachbereitung. Ja, und so ein Testzeitplan, der gibt eben oder Projektzeitplan,
2103400	2113520	der gibt den Rahmen vor, wann getestet werden soll. Der Testzeitplan, der ist allerdings wesentlich
2113520	2124840	detaillierter als ein Projektzeitplan, der enthält eben spezifische Informationen über Testaktivitäten,
2124840	2135440	die für den Projektablauf an sich noch irrelevant wären, die aber für den Testablauf wichtig sind.
2135440	2143280	So, Zusammenfassung im Testplan, da kann man also sagen, die Ziele, da geht es darum, was soll
2143280	2150200	erreicht werden, beim Umfang, was soll getestet werden, bei den Methoden, wie soll getestet werden,
2150200	2157360	bei den Ressourcen, ja, wer testet, mit welchen Werkzeugen. Ja, und der Zeitplan ist einfach, wann
2157360	2169880	wird getestet und die Verantwortlichkeit, wer ist für was zuständig. So, wenn man getestet hat,
2169880	2177120	hatten wir ja vorhin schon gesagt, da ist es wichtig festzuhalten, was dabei rausgekommen ist
2177120	2183040	und wie mit diesen Ergebnissen weiter umgegangen wird. Das heißt, wir müssen hergehen, erstmal
2183040	2191720	ein Testprotokoll erstellen. Bestandteile dessen ist einerseits, ja, da sollte man sagen, um welchen
2191720	2201080	Testfall handelt es sich bei diesem Protokoll. Wie sieht die Einzeltestfallspezifikation aus?
2201080	2208120	Das kann sein, wenn man da so einen Test hat, da habe ich die Frau Meier als Testkandidatin,
2208120	2217080	also als Person, als Mitarbeiterin, die das neue Produkt testet, die also nicht selbst getestet wird,
2217080	2224880	sondern aktiv selbst testet. Ja, da sollte ich in so einem Protokoll etwas sagen, wer war das,
2224880	2229680	wann war das, wo wurde das durchgeführt. Solche Tests kann man ja im Hause des Kunden machen,
2229680	2235480	sowas kann man aber durchaus auch, ja, vielleicht im Hause der Entwicklungsformer machen. Hängt
2235480	2242880	etwas von den Örtlichkeiten und den Beziehungen zwischen Kunden und Auftragenehmern ab. Ja,
2242880	2251520	gibt es Abhängigkeiten zwischen den Testfällen? Welche Aufgaben hat die also bearbeitet? Das
2251520	2259400	wäre hier noch die Testfälle-Identifikation oder die Einzelfallspezifikation. Welche Voraussetzungen
2259400	2265280	sind an die Umgebung gestellt, in der da getestet wird? Ist das eine normale Büroumgebung? Ist das
2265280	2273520	eine großhafte Umgebung? Oder, ja, je nachdem, wer das ist und was das für eine Applikation ist.
2273520	2277760	Wir haben da auch so eine Applikation im Hause, die wird von Hausmeistern benutzt. Da habe ich
2277760	2284640	mal eine ganz andere Umgebung. Da können Teile von der Software auch mal durchaus im Keller
2284640	2292160	benutzt werden, wenn die da in irgendwelchen Geräten irgendwas ablesen müssen und da eine
2292160	2299840	Software haben, die halt abgelesene Messwerte erfasst oder wo Fehlerberichte mal kurz geschrieben
2299840	2309960	werden. Stichpunkte hier in der Heizung, der Öltank leckt oder irgend sowas. Das kann man unter
2309960	2317600	Umständen dann sofort lokal aufnehmen und ja in das Produkt dann weiter einschließen lassen.
2318560	2327360	Hier ist also gut zu protokollieren, wer hat was wann getestet. So, und diese Protokolle,
2327360	2334400	die werden dann anschließend zusammengefasst in einen Testbericht, da werden die Fehlersituationen
2334400	2351000	beurteilt, die Gesamtsituation kommentiert. Ja, das ist sozusagen das Ergebnis. Die Testmethoden,
2351000	2357720	da haben wir so eine gewisse Palette Blackbox-Test, Whitebox-Test. Da möchte ich hier an dieser
2357720	2380920	Stelle nicht mehr drauf eingehen, sondern hier noch auf unterschiedliche Varianten von Tests
2380920	2389160	eingehen. Mal ganz kurz, und zwar zum einen kann man hergehen, Konfigurationen eines Systems
2389160	2396000	überprüfen und da geht es einfach um die Lauffähigkeit des Systems auf einer Zielplattform.
2396000	2403080	Auf einer Zielplattform, das heißt sie haben irgendwie entwickelt auf ihrem PC und entweder
2403080	2408440	muss das jetzt in einer Arbeitsumgebung stattfinden auf einem größeren Rechner oder aber auch auf einem
2408440	2414080	lokalen Device. Ja, der wichtige Unterschied ist, der meistens ist oder oftmals ist die
2414080	2422240	Entwicklungsplattform ungleich der produktiven Plattform, wo das Produkt benutzt wird. Und da
2422240	2428120	muss man eben sehen, auch wenn man eigentlich auf der Entwicklungsplattform alles so schön rund
2428120	2437560	funktionierend hat, das muss auf der Zielplattform gar nicht so der Fall sein. Ja, was man dann auch
2437560	2444000	testen sollte, ist die Installation, ist eine problemlose Installation auf dem Zielsystem möglich?
2444000	2452920	Wie funktioniert das? Wie bringe ich meine entwickelte Produktfassung auf mein Zielsystem?
2452920	2459800	Geht das über den Play Store oder das ist eine einfache Sache? Bei größeren Rechnersystemen gibt
2459800	2467400	es auch entsprechende Verfahren, aber da muss ich eben schauen, habe ich hier alle Schritte berücksichtigt
2467400	2474200	um mein Produkt hier in Betrieb nehmen zu können. Ja, der Funktionstest, das ist halt der Test erfüllt,
2474200	2480560	das System die Anforderungen laut Anforderungsbeschreibung. Dann haben wir so einen Leistungstest, da
2480560	2488960	geht es ja unter Realbedingungen soweit konstruierbar darum, wie werden die Ressourcen ausgelastet,
2488960	2495240	wie sind die Antwortzeiten, wie ist das Lastverhalten, wenn ich da viele Leute vorsetze,
2495240	2505680	viele Nutzer oder wenn Nutzer viele Transaktionen halt durchführen. So, hier muss man das erwartete
2505680	2511360	Verhalten für jeden Einzelfall genau beschreiben und dann die Abweichungen entsprechend dokumentieren.
2511360	2520480	Ja, Benutzbarkeitstests, hier kann man überprüfen, ist das unter ergonomischen Gesichtspunkten so
2520560	2529040	etwas oder gut verwendbar. Das ist bereits in sehr frühen Entwicklungsphasen, wenn sie so horizontale
2529040	2535400	Prototypen angefertigt haben, bereits möglich. Ja, das könnte ein eigenes Teilprojekt sogar sein,
2535400	2541640	die Software Usability. Wenn man sowas zu einem späten Zeitpunkt macht, dann ist man meistens nur
2541640	2546120	noch in der Lage somarisch zu beurteilen, eben wie vorhin gesagt, weil das Produkt schon sehr
2546120	2553920	weit entwickelt ist und größere Änderungen, dann sehr viel Aufwand durchführen. Ja, Sicherheitstests
2553920	2562520	gegebenenfalls durchführen, je nachdem welche Sicherheitsanforderungen davorliegen. Interoperabilitätstests,
2562520	2571560	damit darunter versteht man so Schnittstellen zu anderen Systemen, gerade bei Kommunikationsprodukten.
2571560	2577680	Ja, und wie sieht denn das aus? Und das vergisst man leicht, wenn so ein größeres Produkt, wo viele
2577680	2585760	daran arbeiten, mal komplett abgeschaltet werden müssen. Also Neustart, wie einfach ist der möglich?
2585760	2592200	Wenn wir jetzt alle für unseren Desktop-PC sitzen, ist das eine Trivialität. Aber wie ist das,
2592200	2597600	wenn ich da jetzt mal 500 User habe, über Deutschland verteilt, ist das dann auch noch
2597600	2605720	so einfach möglich? Sollte man bei einem systematisch durchgeführten Test auch mit
2605720	2612160	berücksichtigen. Ja, und die Regulationstests, das sind also die Tests, wo immer wieder bereits
2612160	2622000	durchgeführte Tests nochmal ausgeführt werden, aber ergänzt um Tests für neue Features, die
2622000	2632400	sollte man immer wieder laufen lassen. So, damit habe ich die Thematik des Tests oder des Testens
2632400	2640920	innerhalb des Software-Engineerings angesprochen. Man könnte zum Thema Software-Engineering oder
2640920	2646560	zum Thema Test innerhalb des Software-Engineerings oder Qualitätssicherung eine eigene
2646560	2651760	Lehrveranstaltung machen und deutlich tiefer drin einsteigen. Hier in dieser Veranstaltung
2651760	2658160	ging es ja darum, den Software-Entwicklungsprozess von den Requirements bis zur Fertigstellung anzusprechen
2658160	2667280	in allen Detailfassetten und da ist das Testen nur eine Facette. Wenn wir uns oder wenn Sie sich mit
2667280	2677000	dem Testen weiter befassen möchten, dann kann man das in so Veranstaltungen, Vertiefungen des
2677000	2684360	Software-Engineerings durchaus machen. Da geht man dann sehr ausführlich darauf ein.
